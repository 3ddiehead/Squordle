
	function isNear(a, b) 
    {
        if (a) 
            return (Math.abs(a[0] - b[0]) < 25 && Math.abs(a[1] - b[1]) < 25);
	}

    useEffect(() => {
        if (props.realizeItem[0] && shuckleInfo[1] <= 1)  // SET TO ITEM
            setShuckleInfo([focus.ITEM, shuckleInfo[1]]);
    }, [props.realizeItem[0]])


    useEffect(() => {
        setTimeout(() => {
            if (shuckleInfo[0] === focus.MOUSE) {  // MOUSE TRACKING
                let currPos = [mousePos[0], mousePos[1]]; 
                setTargetPos(currPos);
            }

            if (shuckleInfo[0] === focus.MOBILE) {
                let currPos = [mobileTargetPos[0], mobileTargetPos[1]];
                setTargetPos(currPos);
            }

            if (shuckleInfo[0] === focus.KEY && selectedKey !== null) {  // KEY CASE
                let currPos = [keyPos[0], keyPos[1]]
                setTargetPos(currPos);
            }

            if (shuckleInfo[0] === focus.ITEM) {
                let currPos = [targetInfo[1], targetInfo[2]];
                setTargetPos(currPos);
            }

            let pos = translateSpritePos([targetPos[0] + 15, targetPos[1]], 
                                         shucklePos, 
                                         3);
            setShucklePos([pos[0], pos[1]]);

            if (shuckleInfo[0] !== focus.KEY)
                setTargetReached
                    (isNear(targetPos, shucklePos) || 
                     isNear(mobileTargetPos, shucklePos));
            else
                setTargetReached(isNear(keyPos, shucklePos));
        }, 16);
    }, [mousePos, targetPos, shucklePos, selectedKey]);


        const offscreen = async () => {
            setMobileTargetPos([300, -200]);
            setShuckleInfo([focus.MOBILE, shuckleInfo[1]]);

            await resolveOnceTimedOut(6000);
            if (shuckleInfo[1] === action.BIRTHING)
                setShuckleInfo([shuckleInfo[0], action.LAY_EGG]);
            else
                processEmotion();
        }

//- - --- - - 
    const haltInv = props.haltInv;
    const setHaltInv = props.setHaltInv;

    const [busy, setBusy] = useState(true);

    // ACTION FUNCTIONS --------------------------------------------------------
    function eat()
    {
        let currFocus = focus.MOUSE;
        if (realizeItem[1] === 1)
            currFocus = focus.KEY;

        if (shuckleInfo[1] === action.ANGRY && realizeItem[1] !== 3)
            calmDown(currFocus);
        else 
            setShuckleInfo([currFocus, realizeItem[1]]);

        reset(); 
        setTargetReached(false);
    }

    function process()
    {
        setMobileTargetPos([0,0]);
        setHaltInv(false);
        setShuckleInfo([focus.MOUSE, action.NONPLUSSED]);
    }

    function chooseKey() 
    {
        setTargetReached(false);

        const rand = Math.floor(Math.random() * remainingKeys.length);
        const key = document.getElementById(remainingKeys[rand]);
        const keyPosition = key.getBoundingClientRect();

        setBusy(false);
        setHaltInv(true);
        setKey(key);
        setKeyPos([keyPosition.top, keyPosition.left]);
    }

    function destroy(id)
    {
        const rand = Math.floor(Math.random() * damageList.length);
        selectedKey.style.background = damageList[rand];
        selectedKey.style.pointerEvents = 'none';

        setRemainingKeys(remainingKeys.filter(k => k !== id));
        setTargetReached(false);
        setKey(null);
        setKeyPos(null);
    }

    function calmDown(currFocus)
    {
        setKey(null);
        setKeyPos(null);
        setShuckleInfo([currFocus, action.SING]);
    }

    function becomeSatiated()
    {
        setShuckleInfo([focus.MOUSE, 0]);
        setTargetReached(false);
        setHaltInv(false);
        setBusy(false);
    }

    // Move toward item IF (realized || nonplussed || angry)

    useEffect(() => {
        if (realizeItem[0] && selectedKey === null)  // set to item 
            setShuckleInfo([focus.ITEM, shuckleInfo[1]]);

        if (shuckleInfo[0] === focus.KEY) {  // set to key (angry) 
            if (selectedKey === null && remainingKeys.length > 0)
                chooseKey();
            if (remainingKeys.length <= 0)   // exit case
                becomeSatiated();  // for now...
        }
    }, [realizeItem[0], keyPos]);
    
    useEffect(() => {
        const eatItem = async () => {
            await resolveOnceTimedOut(5000); 
            eat();
        };

        const destroyKey = async () =>
        {
            await resolveOnceTimedOut(5000);
            destroy(selectedKey.id);
        };

        if (targetReached && 
            shuckleInfo[0] === focus.ITEM && shuckleInfo[1] <= 1)
            eatItem();  // prev shuckleInfo check redundant?

        if (shuckleInfo[0] === focus.KEY && targetReached && !busy) {
            setBusy(true);
            destroyKey();
        }

    }, [targetReached, selectedKey, shuckleInfo[0], shuckleInfo[1], busy]);

    useEffect(() => {
        const processEmotion = async () => {
            await resolveOnceTimedOut(3000);
            process();
        }

        switch (shuckleInfo[1]) {
            case action.HAPPY:
            case action.SING:
            case action.CONFUSED:
                processEmotion();
                break;
            case action.SHINY:
                let tempInfo = JSON.parse(localStorage.shuckleInfo);
                tempInfo['shiny'] = true;
                localStorage.setItem('shuckleInfo', JSON.stringify(tempInfo));
                break;
            case action.ANGRY:
            case action.NONPLUSSED:
            default:
                break;
        }
    }, [shuckleInfo[1]]);
